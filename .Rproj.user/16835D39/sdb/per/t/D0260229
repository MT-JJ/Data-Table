{
    "collab_server" : "",
    "contents" : "library(data.table)\n'%notin%'<-Negate('%in%')\nlistrep2datatable_fn<-function(X,left_varname=NULL,right_varname=NULL){\n  require(data.table)\n  if(is.list(X)==F) {stop(\"Need to enter a list of named vectors\")}\n  if(is.null(left_varname)){left_varname=\"V1\"} else{left_varname=left_varname}\n  if(is.null(right_varname)){right_varname=\"V2\"} else{right_varname=right_varname}\n  X<-lapply(lapply(X,function(i) t(t(i))),data.table)\n  New_item_vector<-rbindlist(lapply(seq_along(X),function(i) setnames(X[[i]][,V2:=rep(names(X)[i],sapply(X,nrow)[i])],c(right_varname,left_varname))))\n  return(New_item_vector)\n}\n\ndt_to_named_list<-function(X){\n  X<-setattr(lapply(lapply(lapply(X,list),function(i) lapply(unlist(i),list)),function(j) unlist(unname(j),recursive = F))$Pooled_SD,\"names\",lapply(lapply(x,function(i) lapply(unlist(i),list)),function(j) unlist(unname(j),recursive = F))$Covariates)\n}\n\n\nnumeric_converter<-function(X){\n  X<-ifelse(sum(is.na(suppressWarnings(as.numeric(X))))==length(X),0,1)\n return(X)\n}\n\nProper_Name_fn<-function(X){\n  X<-ifelse(is.na(X),NA,paste0(toupper(substring(X,1,1)),tolower(substring(X,2,nchar(X)))))\n  return(X)\n}\n\nInconsistency_check<-function(X){\n  #X is a melted data.table of two merged data.tables that have the same \"variables\" and \"values\" column names from defaults assumes you melted by the ID variable.\n  IDvar<-colnames(X)[1]\n  uniquevar<-unique(gsub(\"^i.\",\"\",grep(\"^i\",X$variable,value = T)))\n  melted_lists<-setattr(lapply(lapply(uniquevar,function(i) X[grep(i,variable),]),function(j) dcast(j,paste(IDvar,\"~\",\"variable\"))),\"names\",uniquevar)\n  test_results<-lapply(melted_lists,function(i) all.equal(i[,2,with=F],i[,3,with=F],check.attributes=F))\n  print(test_results)\n  return(melted_lists)\n}\n\nStatsDT_fn<-function(X,groupvars,outcome_vars=NULL,ID=NULL,stat_col=T,group_col=T,varcol=T,nlevels_cont=10,round_digit=2,percents=T){\n  print(paste(\"Assuming\",sQuote(groupvars[1]),\"is the treatment variable. If not please re-enter your grouping variables with the treatment variable as the first variable.\"))\n  #print(length(groupvars))\n  if(group_col!=F){\n    if(length(groupvars)>1){\n      ll<-list(groupvars=unlist(strsplit(gsub(\"^c|[[:punct:]]\",\"\",deparse(match.call()$\"groupvars\")),split = \" \")))\n      mult_group_vars=T\n      if(group_col==T){\n        stop(\"You entered multiple grouping variables an indicated you wanted them in columns so you need to specify which of them to include in columns. Re-run the function by replacing the 'T' in 'group_col' with a character vector of variable names or 'A' if you want all of them in columns.\")\n      }\n      if(group_col==\"A\") {group_col<-groupvars}\n      \n  } else {mult_group_vars=F}\n  } else {mult_group_vars=F} #This is case where group_col=F which overrides the multiple variables in groupvars since they won't be printed in columns anyway.\n  \n  #This changes value in group_col to name of the single group variable in groupvars for consistency later.\n  if(group_col==T&mult_group_vars==F){\n    ll<-lapply(as.list(match.call())[\"groupvars\"],as.name)\n    group_col<-groupvars\n  }\n  \n  #Creates X without ID variable and identifies outcome variables\n  if(is.null(outcome_vars)){\n    if(is.null(ID)){\n      outcome_vars<-colnames(X)[-match(groupvars,colnames(X))]\n    } else {\n      outcome_vars<-colnames(X)[-match(c(groupvars,ID),colnames(X))]\n      X<-X[,-ID,with=F]\n      print(paste(\"Assuming ID variable is\", sQuote(match.call()$ID),\"and removing it.\"))\n      }\n  } else{\n    if(!is.null(ID)){ X<-X[,-ID,with=F]}\n  }\n  X<-X[,c(groupvars,outcome_vars),with=F]\n  #Identifying which variables are continuous for adding percents later.\n  continuous_vars<-names(which(sapply(X,function(i) length(unique(i))>nlevels_cont)==T))\n  \n  #Checking for missing values in groupvars and recoding them to unknown as necessary\n  grouplist_test<-copy(X)[,groupvars,with=F]\n  invisible(lapply(seq_along(grouplist_test),function(i) if(sum(is.na(grouplist_test[[i]]))>1){\n    print(paste(\"WARNING:\",groupvars[i],\"has\",sum(is.na(grouplist_test[[i]])), \"missing values. Coding them to Unknown.\")) \n    X[,groupvars[i]:=lapply(.SD,function(x) as.character(ifelse(is.na(X[[x]]),\"Unknown\",X[[x]]))),.SDcols=groupvars[i]]\n    }))\n  \n  ##Calculating stats by interacting the group variables\n  grouplist<-lapply(groupvars,function(i) as.character(X[[i]]))\n  Mod_X<-copy(X)[,Group:=interaction(grouplist)]\n  results_list<-setattr(lapply(outcome_vars,function(j) Mod_X[is.na(Mod_X[[j]])==F,lapply(.SD,function(i) list(N=.N,Mean=format(round(mean(i,na.rm=T),round_digit),nsmall=round_digit),SD=format(round(sd(i,na.rm=T),round_digit),nsmall=round_digit))),by=groupvars,.SDcols=j][,Stat:=rep(c(\"N\",\"Mean\",\"SD\"),length(unique(interaction(grouplist))))]),\"names\",outcome_vars)\n  \n  raw_results<-Reduce(function(...) merge(...,by=c(groupvars,\"Stat\"),all=T), results_list)[,lapply(.SD,as.character)][,Stat:=factor(Stat,levels = c(\"N\",\"Mean\",\"SD\"))]\n  \n  \n  if(percents==T){\n    percent_cols<-colnames(raw_results)[-match(c(groupvars,\"Stat\",continuous_vars),colnames(raw_results))]\n    \n    raw_results<-copy(raw_results)[Stat==\"Mean\",eval(percent_cols):=lapply(.SD,function(i) paste0(as.character(round(as.numeric(i)*100,0)),\"%\")),.SDcols=eval(percent_cols)]\n  }\n \n  ####Creating the casting layout for final results starting with whether there are multiple grouping variables and then whether user wants a variable column or if they should be spread in a wide format.\n  stat_var_ind<-interaction(varcol,stat_col)\n  recast<-NULL\n#Group_col can only take on False and char string\n  if(group_col==F){\n             switch(as.character(stat_var_ind),\n                    \"TRUE.TRUE\"={\n                      dcast_formula<-paste(\"variable\",\"+\",\"Stat\",\"~\",paste0(groupvars,collapse = \"+\"))},\n                    \"TRUE.FALSE\"={\n                      dcast_formula<-paste(\"variable\",\"~\",paste0(c(\"Stat\",groupvars),collapse = \"+\"))},\n                    \"FALSE.TRUE\"={\n                      dcast_formula<-paste(\"Stat\",\"~\",paste0(c(\"variable\",groupvars),collapse = \"+\"))},\n                    {stop(\"Need at least one column\")})\n           } else {\n             switch(as.character(stat_var_ind),\n                    \"FALSE.FALSE\"={\n                      dcast_formula<-paste(paste0(group_col,collapse=\"+\"),\"~\",paste0(c(\"variable\",\"Stat\",groupvars[-match(groupvars,group_col)]),collapse = \"+\"))},\n                    \"TRUE.FALSE\"={\n                      dcast_formula<-paste(paste0(c(\"variable\",group_col),collapse=\"+\"),\"~\",paste0(c(\"Stat\",groupvars[-match(groupvars,group_col)]),collapse = \"+\"))},\n                    \"FALSE.TRUE\"={\n                      dcast_formula<-paste(paste0(c(group_col,\"Stat\"),collapse=\"+\"),\"~\",paste0(c(\"variable\",groupvars[-match(groupvars,group_col)]),collapse = \"+\"))},\n                    {recast=F})\n           }\n  if(is.null(recast)){\n    \n    final_results<-dcast(melt(raw_results,id.vars=c(groupvars,\"Stat\"),variable.factor=F),dcast_formula)\n  } else {\n    final_results<-melt(raw_results,id.vars=c(groupvars,\"Stat\"),variable.factor=F)\n  }\n  \n  return(final_results)\n}\n\nCreate_excel_fn<-function(datatlists,sheetnames,filename){\n  require(openxlsx)\n  if(is.list(datatlists)==F){stop(\"Need to enter as lists\")}\n  if(is.list(sheetnames)==F){sheetnames=as.list(sheetnames)}\n  if(grepl(\".xlsx$\",filename)==F){stop(\"Enter proper filename *.xlsx\")}\n  wb<-createWorkbook()\n  invisible(lapply(unlist(sheetnames),function(i) addWorksheet(wb,i)))\n  invisible(lapply(seq_along(sheetnames),function(i) writeData(wb,unlist(sheetnames)[i],datatlists[[i]])))\n  saveWorkbook(wb,filename,overwrite = T)\n  \n}\n\nPretty_excel_print<-function(stat_dt,grouping_col=NULL,stat_col=NULL,var_col=NULL,grouped_col=NULL,filename=NULL,sheetname=NULL,append=F,...){\n  \n  X<-data.table(stat_dt)\n  col_pattern=NULL\n  #No grouped column info and no variable column implying columns are grouped by variables but unknown info to shade\n  if(is.null(var_col)&is.null(grouping_col)){\n    if(!is.null(grouping_col)&!is.null(stat_col)){\n      ll<-lapply(as.list(match.call())[c(\"stat_dt\",\"grouping_col\",\"stat_col\")],as.name)\n      nvar<-length(colnames(X)[-match(c(grouping_col,stat_col),colnames(X))])\n      group_pattern<-X[,rle(eval(ll$grouping_col))$length]\n      stat_pattern<-X[,rle(eval(ll$stat_col))$length]\n      \n      group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))!=1)]\n      non_group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))==1)]\n      X<-setcolorder(copy(X),c(group_var,non_group_var,colnames(X)[-match(c(group_var,non_group_var),colnames(X))]))\n      row_ind<-\"inner\"\n    } else {stop(\"Insufficient information to group columns. Either use the 'Create Excel' function to print as is or enter the number of columns in each group.\")}\n  }\n  #No grouped call but var_col is present\n  if(!is.null(var_col)&is.null(grouped_col)){\n    if(!is.null(grouping_col)&!is.null(stat_col)){\n      ll<-lapply(as.list(match.call())[c(\"stat_dt\",\"grouping_col\",\"stat_col\",\"var_col\")],as.name)\n      nvar<-X[,length(rle(eval(ll$var_col))$values)]\n      nvar_rep<-X[,unique(rle(eval(ll$var_col))$lengths)]\n      group_pattern<-X[,rle(eval(ll$grouping_col))$length]\n      stat_pattern<-X[,rle(eval(ll$stat_col))$length]\n      group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))!=1)]\n      non_group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))==1)]\n      X<-setcolorder(copy(X),c(var_col,group_var,non_group_var,colnames(X)[-match(c(var_col,group_var,non_group_var),colnames(X))]))\n      row_ind<-\"Outer\"\n    } else {stop(\"Insufficient information to group columns. Either use the 'Create Excel' function to print as is or enter the number of columns in each group.\")}\n  }\n  \n  #This is when grouped col is indicated and so gets a little more complicated because there may be both row and column shading so will require a switch statement based on different scenarios.\n  grouped_col_ind<-as.character(interaction(is.null(grouping_col),is.null(stat_col)))\n  if(!is.null(grouped_col)&!is.null(var_col)){\n    switch(grouped_col_ind,\n           \"FALSE.FALSE\"={\n             ll<-lapply(as.list(match.call())[c(\"stat_dt\",\"grouping_col\",\"stat_col\",\"var_col\")],as.name)\n             group_pattern<-X[,rle(eval(ll$grouping_col))$length]\n             stat_pattern<-X[,rle(eval(ll$stat_col))$length]\n             group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))!=1)]\n             non_group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))==1)]\n             X<-setcolorder(copy(X),c(var_col,group_var,non_group_var,colnames(X)[-match(c(var_col,group_var,non_group_var),colnames(X))]))\n             col_pattern<-seq(4,ncol(X),by=grouped_col)\n             row_ind<-\"Outer\"\n           },\n           \"TRUE.TRUE\"={\n             col_pattern<-seq(2,ncol(X),by=grouped_col)\n             row_ind<-\"None\"\n           },\n           { #Default for switch is one or the other\n             ll<-lapply(as.list(match.call())[c(\"stat_dt\",\"var_col\")],as.name)\n             nvar<-X[,length(rle(eval(ll$var_col))$values)]\n             nvar_rep<-X[,unique(rle(eval(ll$var_col))$lengths)]\n             if(!is.null(stat_col)){\n               ll<-append(ll,list(stat_col=as.name(stat_col)))\n               stat_pattern<-X[,rle(eval(ll$stat_col))$length]\n               if(nvar_rep!=1){\n                 group_var<-var_col\n                 non_group_var<-stat_col\n               } else {\n                 group_var<-stat_col\n                 non_group_var<-var_col\n               }\n             } else{\n               ll<-append(ll,list(grouping_col=as.name(grouping_col)))\n               group_pattern<-X[,rle(eval(ll$grouping_col))$length]\n               if(nvar_rep!=1){\n                 group_var<-var_col\n                 non_group_var<-grouping_col\n               } else {\n                 group_var<-grouping_col\n                 non_group_var<-var_col\n               }\n               }\n               X<-setcolorder(copy(X),c(group_var,non_group_var,colnames(X)[-match(c(group_var,non_group_var),colnames(X))]))\n               col_pattern<-seq(3,ncol(X),by=grouped_col)\n               row_ind<-\"inner\"\n           })\n  }\n  ##This is when var column is missing but column shading is wanted\n  if(!is.null(grouped_col)&is.null(var_col)){\n    switch(grouped_col_ind,\n           \"FALSE.FALSE\"={\n             ll<-lapply(as.list(match.call())[c(\"stat_dt\",\"grouping_col\",\"stat_col\")],as.name)\n             group_pattern<-X[,rle(eval(ll$grouping_col))$length]\n             stat_pattern<-X[,rle(eval(ll$stat_col))$length]\n             \n             group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))!=1)]\n             non_group_var<-c(grouping_col,stat_col)[which(list(mean(group_pattern),mean(stat_pattern))==1)]\n             X<-setcolorder(copy(X),c(group_var,non_group_var,colnames(X)[-match(c(group_var,non_group_var),colnames(X))]))\n             col_pattern<-seq(3,ncol(X),by=grouped_col)\n             row_ind<-\"inner\"\n           },\n           \"TRUE.TRUE\"={\n          \n             col_pattern<-seq(2,ncol(X),by=grouped_col)\n             row_ind<-\"None\"\n           },\n           {#Default for switch is one or the other and so only need the first variable anyway so  no need for anything else.\n             col_pattern<-seq(2,ncol(X),by=grouped_col)\n             row_ind<-\"None\"\n           })\n  }\n  \n  ####Starting to create workbook\n  #####Style parameters\n  header_style<-createStyle(textDecoration = \"bold\",fontSize = 14,halign = \"center\",fgFill = \"azure3\",border = \"TopBottom\",borderColour = \"black\",borderStyle = \"thick\")\n  ##Creating Shading and Centering Styles and borders\n  shade<-createStyle(fgFill = \"azure2\")\n  font<-createStyle(fontSize = 12)\n  outer_shade<-createStyle(fgFill = \"azure3\",textDecoration = \"bold\",fontSize = 14)\n  center_cell<-createStyle(halign = \"center\")\n  merge_center<-createStyle(valign = \"center\",halign = \"center\")\n  bottom_border<-createStyle(border = \"bottom\",borderStyle = \"thick\")\n  top_border<-createStyle(border = \"top\",borderStyle = \"thick\")\n  col_border<-createStyle(border=\"left\",borderStyle = \"medium\",borderColour = \"blue\")\n  if(is.null(sheetname)){\n    sheetname<-as.character(match.call()$stat_dt) \n  }\n  if(is.null(filename)){filename<-paste0(c(sheetname,\"xlsx\"),collapse = \".\")}\n  \n  ###Creating Workbook\n  if(append==F){\n  wb<-createWorkbook()\n  } else {\n    print(paste0(c(getwd(),filename),collapse=\"/\"))\n    wb<-loadWorkbook(paste0(c(getwd(),filename),collapse=\"/\"))\n  }\n  addWorksheet(wb,sheetname,gridLines = F,orientation = \"landscape\")\n  writeData(wb,sheetname,X,borders = \"surrounding\",borderStyle = \"thick\",borderColour = \"black\")\n  ###Header\n  invisible(addStyle(wb,sheetname,style = header_style,rows = 1,cols = seq_along(X)))\n  invisible(addStyle(wb,sheetname,style = createStyle(border = \"right\",borderStyle = \"thick\",borderColour = \"black\"),rows = 1,cols=ncol(X),stack = T))\n  ###Centering data cells and enlarging font size\n  invisible(addStyle(wb,sheetname,style = font,cols=seq_along(X)[-1],rows=X[,seq_along(.I)]+1,gridExpand = T,stack = T))\n  \n  #########Creating vectors for row shading and merging\n  #Function to generate sequences by recursively adding the rle patterns of grouping variables\n  seq_fn<-function(starting,rle_vector){\n    a<-starting\n    x<-rle_vector\n    for(i in seq_along(x)[-length(x)]){\n      a<-c(a,a[i]+x[i])\n    }\n    return(a)\n  }\n  switch(row_ind,\n         \"Outer\"={\n           outer_pattern<-rle(X[[1]])$lengths\n           startMergeStat<-seq_fn(2,outer_pattern)\n           inner_pattern<-rle(X[[2]])$lengths\n           startMergeGroup<-seq_fn(2,inner_pattern)\n           \n           MergeStatrow<-lapply(seq_along(startMergeStat),function(i) seq(startMergeStat[i],length.out = outer_pattern[i]))\n           MergeGrouprow<-lapply(seq_along(startMergeGroup),function(i) seq(startMergeGroup[i],length.out = inner_pattern[i]))\n           \n           invisible(addStyle(wb,sheetname,style = center_cell,cols=seq_along(X)[-c(1:3)],rows=X[,seq_along(.I)]+1,gridExpand = T,stack = T))\n##Shading inner grouping column Rows by alternating\n           shade_rows<-MergeGrouprow[seq(1,length(MergeGrouprow),by=2)]\n\n           invisible(lapply(seq_along(MergeStatrow),function(i) addStyle(wb,sheetname,style=shade,cols=seq_along(readWorkbook(wb,sheetname))[-1],rows=shade_rows[[i]],gridExpand = T,stack = T)))\n           \n           ##Merging Cells\n           #Outer\n           invisible(lapply(seq_along(MergeStatrow),function(i) mergeCells(wb,sheetname,cols=1,rows=MergeStatrow[[i]])))\n           #Inner\n           invisible(lapply(seq_along(MergeGrouprow),function(i) mergeCells(wb,sheetname,cols=2,rows=MergeGrouprow[[i]])))\n           \n           ##Centering inner and outer\n           invisible(addStyle(wb,sheetname,style=merge_center,cols=1:2,rows=c(1,X[,seq_along(.I)]+1),gridExpand = T,stack = T))\n           ####Adding Borders around outer and the bottom of table\n           invisible(addStyle(wb,sheetname,style=top_border,cols = seq_along(X),rows = startMergeStat,gridExpand = T,stack = T))\n           \n           invisible(addStyle(wb,sheetname,style=bottom_border,cols = seq_along(X),rows = nrow(X)+1,gridExpand = T,stack = T))\n           \n         },\n\n         \"Inner\"={\n           inner_pattern<-rle(X[[1]])$lengths\n           startMergeGroup<-seq_fn(2,inner_pattern)\n           MergeGrouprow<-lapply(seq_along(startMergeGroup),function(i) seq(startMergeGroup[i],length.out = inner_pattern[i]))\n           \n           invisible(addStyle(wb,sheetname,style = center_cell,cols=seq_along(X)[-c(1:2)],rows=X[,seq_along(.I)]+1,gridExpand = T,stack = T))\n           border_rows<-MergeGrouprow[seq(1,length(MergeGrouprow),by=2)]\n           ##Merging and Centering Inner Cells\n           invisible(lapply(seq_along(MergeGrouprow),function(i) mergeCells(wb,sheetname,cols=2,rows=MergeGrouprow[[i]])))\n           invisible(addStyle(wb,sheetname,style=merge_center,cols=1,rows=c(1,X[,seq_along(.I)]+1),gridExpand = T,stack = T))\n           ##Adding border at bottom of table\n           invisible(addStyle(wb,sheetname,style=bottom_border,cols = seq_along(X),rows = nrow(X)+1,gridExpand = T,stack = T))\n         },\n         \"None\"={\n           print(\"No grouping by rows indicated defaulting to alternating row shading.\")\n           invisible(addStyle(wb,sheetname,style = center_cell,cols=seq_along(X)[-1],rows=X[,seq_along(.I)]+1,gridExpand = T,stack = T))\n           invisible(addStyle(wb,sheetname,style = shade,cols = seq_along(X)[-1],rows = seq(2,nrow(X)+1,by=2),gridExpand = T,stack = T))\n         })\n  \n  ###Setting Column Widths to Auto and also assuring fint of first column is bold with larger font.\n  ##Shading Outer Column and centering\n  invisible(addStyle(wb,sheetname,style=outer_shade,cols=1,rows = c(1,X[,seq_along(.I)]+1),stack = T))\n  invisible(setColWidths(wb,sheetname,cols=seq_along(X),widths = \"auto\"))\n  ###Adding column borders if desired\n  if(!is.null(col_pattern)){\n    invisible(addStyle(wb,sheetname,style=col_border,cols = col_pattern,rows=seq(1,nrow(X)+1),gridExpand = T,stack = T))\n  }\n  \n  print(paste(\"Saving\",sQuote(filename),\"to\",getwd()))\n    saveWorkbook(wb,filename,overwrite = T)\n  \n}\n\n\nMissingness_fn<-function(datatable,IDname,numvarspergraph=20){\n  require(ggplot2)\n  ID=IDname\n  if(is.null(ID)){stop(\"Please input ID column\")}\n  IDcol<-unname(unlist(copy(datatable)[,ID,with=F]))\n  y=numvarspergraph\n  X<-copy(datatable)[,-ID,with=F]\n  X<-copy(X)[,colnames(X):=lapply(.SD,function(i) as.numeric(is.na(i))),.SDcols=colnames(X)]\n  Percent_missing<-setorder(setkey(setnames(data.table(round(data.frame(t(X[,lapply(.SD,function(i) mean(i)*100)])),4),keep.rownames = \"Variable\"),2,\"Percent.Missing\"),Percent.Missing),-Percent.Missing)\n  Graphs_plot_ind<-suppressWarnings(copy(Percent_missing)[,Var_subset:=rep(paste0(\"Graph\",seq_along(seq(1,nrow(copy(Percent_missing)),y))),rep(y,length(seq_along(seq(1,nrow(copy(Percent_missing)),y)))))])\n  Miss_patterns<-data.table(t(X[,colnames(X):=lapply(.SD,function(i) car::recode(i,\"1='X'\"))]))[,lapply(.SD,function(i) paste0(i,collapse = \"\"))]\n  Pattern<-setnames(data.table(sort(table(unlist(Miss_patterns)),decreasing = T)),\"V1\",\"Pattern\")\n  Percent_plot<-lapply(split(Graphs_plot_ind,Graphs_plot_ind$Var_subset), function(i) ggplot(data=i,aes(x=Variable,y=Percent.Missing))+geom_point()+coord_flip()+theme_bw())\n  Miss_pat_tmp<-copy(datatable)[,Miss_patterns:=c(t(Miss_patterns))][,Miss_patterns:=factor(Miss_patterns,levels=names(sort(table(Miss_patterns),decreasing = T)))]\n\n  Missing_names_sum<-lapply(lapply(lapply(seq_along(levels(Miss_pat_tmp$Miss_patterns)),function(i) unlist(strsplit(levels(Miss_pat_tmp$Miss_patterns)[i],\"\"))),function(j) setNames(j,colnames(X))),function(k) names(which(k==\"X\")))\n  \n  return(list(Percent_missing=Percent_missing[,Percent.Missing:=paste0(Percent.Missing,\"%\")],Missing_counts=Pattern,Percent_plot=Percent_plot,datatable=Miss_pat_tmp,Miss_pat_labels=Missing_names_sum))\n}\n\nOdds_ratio_fn<-function(glmmodel){\n  est<-exp(coef(glmmodel))\n  var.diag<-diag(vcov(glmmodel))\n  std.error=sqrt(est^2 * var.diag)\n  results<-data.table(summary(glmmodel)$coef,keep.rownames = \"Parameters\")[,Estimate:=est][,`Std. Error`:=std.error][,c(2:5):=lapply(.SD,function(i) round(i,4)),.SDcols=c(2:5)]\n  return(results)\n}\n\ncor.prob<-function (X,use=\"complete.obs\",method=\"pearson\",alternative=\"two.sided\") {\n  require(\"Matrix\")\n  namesc<-colnames(X)\n  n=ncol(X)\n  test_list<-lapply(lapply(combn(namesc,2,simplify = F),function(i) paste0(\"~\",paste0(i,collapse=\"+\"))),function(j) cor.test(as.formula(j),data=X,method = method,alternative = alternative))\n  UniqueR<-round(na.omit(matrix(t(car::recode(upper.tri(cor(X)),\"'FALSE'=NA\")*cor(X,use=use,method=method)))),digits=4)\n  \n  UniqueRsig<-data.table(data.frame(Corr=UniqueR,p_val=unlist(lapply(test_list,\"[[\",\"p.value\")),Corr_form=format(UniqueR,nsmall=4)))[,Corr_sig:=paste0(Corr_form,ifelse(abs(p_val) < .001, \"***\", ifelse(abs(p_val) < .01, \"** \", ifelse(abs(p_val) < .05, \"* \", \" \"))))][,p_val:=format(round(p_val,digits=4),nsmall=4)][,Test_name:=unlist(lapply(test_list,\"[[\",\"data.name\"))]\n  \n  test_fn<-function(X){\n    starting<-list(X)\n    Y<-UniqueRsig$Corr_sig\n    Z<-UniqueRsig$p_val\n    listnames<-UniqueRsig$Test_name\n    for(i in seq_along(X)){\n      starting[[i]]<-rbind(Test=listnames[1:X[i]],Corr_sig=Y[1:X[i]],p_val=Z[1:X[i]])\n      Y<-Y[-c(1:X[i])]\n      Z<-Z[-c(1:X[i])]\n      listnames<-listnames[-c(1:X[i])]\n    }\n    return(starting)\n  }\n  \n  ragged_corlist<-unlist(list(lapply(test_fn((n-1):0),function(i) unlist(melt(data.table(i,keep.rownames = T),id.vars=\"rn\")[rn!=\"Test\",value])),list(character(0))),recursive = F)[-n]\n  \n  even_corlist<-setcolorder(data.table(data.frame(setattr(lapply(seq_along(namesc),function(i) c(rep(c(NA,1,NA),c(2*(i-1),1,1)),ragged_corlist[[i]])),\"names\",namesc)))[,Items:=rapply(lapply(namesc,function(i) c(i,\"p_value\")),c)],c(\"Items\",namesc))\n  return(even_corlist)\n}\n\nchar_quote_fn<-function(X,sep_char=\",\"){\n  options(useFancyQuotes = F)\n  X<-cat(dQuote(unlist(lapply(unlist(strsplit(X,sep_char)),function(i) list(trimws(i))),recursive = F)),sep=\",\")\n  \n}\n\nindicator_converter<-function(X){\n  \n  categorical_vars<-names(which(sapply(X,is.factor)))\n  if(length(categorical_vars)>0){\n    cat(\"Assuming the following are the only factors you need to convert:\")\n    char_quote_fn(categorical_vars)\n  } else {stop(\"You need to convert the variables of interest to factors.\")}\n  X<-data.table(X)\n  cat_ref<-paste0(categorical_vars,unlist(lapply(categorical_vars,function(i) levels(copy(X)[[i]])[1])))\n  \n  categorical_list<-lapply(categorical_vars,function(i) data.table(data.frame(model.matrix(as.formula(paste(\"~\",i)),X))))\n  \n  categorical_expand<-Reduce(cbind,lapply(seq_along(categorical_list),function(i) categorical_list[[i]][,cat_ref[i]:=1*(rowSums(copy(.SD))==1)][,-\"X.Intercept.\",with=F]))\n  return(cbind(X[,-categorical_vars,with=F],categorical_expand))\n}\n#setwd(\"~/Documents/aaaOLPD/Data Sets\")\n#save.image(file = \"Data.tablefuns.RData\")",
    "created" : 1518215028404.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2746111357",
    "id" : "D0260229",
    "lastKnownWriteTime" : 1518034272,
    "last_content_update" : 1518034272,
    "path" : "~/Documents/aaaOLPD/Data Sets/Data.table.fns/Data.tablefuns.R",
    "project_path" : "Data.tablefuns.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}